// deno-lint-ignore-file no-explicit-any
import UUIDMap from "../Utils/UUIDMap";
import TypeDetector from "./TypeDetector";
import UniversalHandler from "../Handlers/UniversalHandler";
import { isPromise, doOnlyAfterResolve } from "../Utils/Useful";
import { extract } from "../Utils/InstructionType";
import { wrapMeta } from "../Handlers/UniversalHandler";
import ORG from "../Utils/OrganicType";
import { PMS, TS } from "../Utils/Alias";

//
export const hasMemoryBuffer = (target: any): boolean =>
    ((target as any)?.buffer instanceof ArrayBuffer) ||
    (typeof SharedArrayBuffer !== TS.udf && (target as any)?.buffer instanceof SharedArrayBuffer);

export default class PreCoding {
    $encoder = new Map<
        string,
        (organic: boolean, target: unknown, transfer: unknown[]) => unknown
    >();
    $decoder = new Map<
        string,
        (organic: boolean, target: unknown, transfer: unknown[]) => unknown
    >();
    $mp = new UUIDMap();
    $hndr = new UniversalHandler();
    $typeDetector = new TypeDetector();

    constructor(memoryPool: UUIDMap = new UUIDMap()) {
        this.$mp = memoryPool;

        this.$encoder = new Map([
            [
                "a",
                (organic: boolean, target: unknown, transfer: unknown[] = []) => {
                    if (!organic) {
                        const items = Array.from((target as any[]) || []);
                        const encoded = items.map((e) => this.encode(e, transfer));
                        return encoded.some(isPromise) ? PMS.all(encoded) : encoded;
                    }
                    return target;
                },
            ],
            [
                "tf",
                (organic: boolean, target: unknown, transfer: unknown[] = []) => {
                    if (!organic) {
                        if (transfer.indexOf(target) < 0 && target) {
                            const uuid: string = (this.$mp.get(target) || "") as string;
                            this.$mp.delete(target);

                            const toTransfer = hasMemoryBuffer(target)
                                ? ((target as any).buffer ?? target)
                                : target;
                            if (toTransfer) {
                                transfer.push(toTransfer);
                            }

                            if (uuid) {
                                return {
                                    [ORG.type]: "tf",
                                    [ORG.uuid]: uuid,
                                    [ORG.node]: toTransfer,
                                };
                            }
                        }
                    } else {
                        const org = (extract(target) || {}) as any;
                        const node =
                            (org && org[ORG.node]) ?? this.$mp.get(org?.[ORG.uuid] as string);
                        if (node) {
                            const uuid: string = (org?.[ORG.uuid] ||
                                this.$mp.get(node) ||
                                "") as string;
                            const meta = {
                                [ORG.type]: "tf",
                                [ORG.uuid]: uuid,
                                [ORG.node]: node,
                            };

                            if (node && transfer.indexOf(node) < 0) {
                                this.$mp.delete(node);
                                transfer.push(hasMemoryBuffer(node) ? ((node as any).buffer ?? node) : node);
                            }

                            if (org && uuid) {
                                org[ORG.type] = "ref";
                                org[ORG.node] = null;
                            }
                            return meta;
                        }
                        return org;
                    }
                    return target;
                },
            ],
            [
                "ref",
                (organic: boolean, target: unknown, _transfer: unknown[] = []) => {
                    if (!organic || (target as any)?.[ORG.data]) {
                        const ext = (extract(target) as any)?.[ORG.uuid] as string;
                        const exists = this.$mp.get(ext) ?? target;
                        return {
                            [ORG.type]: "ref",
                            [ORG.uuid]: this.$mp.add(exists as any, ext, !organic),
                        };
                    }
                    return target;
                },
            ],
        ]);

        this.$decoder = new Map([
            [
                "a",
                (organic: boolean, target: unknown, transfer: unknown[] = []) => {
                    if (!organic) {
                        const items = Array.from(target as any[]);
                        const decoded = items.map((e) => this.decode(e, transfer));
                        return decoded.some(isPromise) ? PMS.all(decoded) : decoded;
                    }
                    return target;
                },
            ],
            [
                "tf",
                (organic: boolean, target: unknown, _transfer: unknown[] = []) => {
                    if (organic) {
                        const org = extract(target) as any;
                        const node =
                            (org && org[ORG.node]) ??
                            this.$mp.get(org?.[ORG.uuid] as string);
                        if (node) {
                            org[ORG.uuid] = this.$mp.add(node, org[ORG.uuid] as string, organic);
                            org[ORG.type] = "ref";
                        }
                        return node ?? wrapMeta(org, this.$hndr);
                    }
                    return target;
                },
            ],
            [
                "ref",
                (organic: boolean, target: unknown, _transfer: unknown[] = []) => {
                    if (organic) {
                        const org = extract(target) as any;
                        const exists = this.$mp.get(org?.[ORG.uuid] as string);
                        return exists ?? wrapMeta(org, this.$hndr);
                    }
                    return target;
                },
            ],
        ]);
    }

    $decode(target: unknown, transfer: unknown[] = []): unknown {
        const [organic, type] = this.$typeDetector.detectType(target, transfer);
        return this.$decoder.has(type)
            ? this.$decoder.get(type)?.(organic, target, transfer) ?? target
            : target;
    }

    $encode(target: unknown, transfer: unknown[] = []): unknown {
        const [organic, type] = this.$typeDetector.detectType(target, transfer);
        return this.$encoder.has(type)
            ? this.$encoder.get(type)?.(organic, target, transfer) ?? target
            : target;
    }

    decode(target: unknown | Promise<unknown>, transfer: unknown[] = []): unknown {
        return doOnlyAfterResolve(target, (e) => this.$decode(e, transfer));
    }

    encode(target: unknown | Promise<unknown>, transfer: unknown[] = []): unknown {
        return doOnlyAfterResolve(target, (e) => this.$encode(e, transfer));
    }
}