// deno-lint-ignore-file no-explicit-any
import TS from "../Utils/Alias";
import { extract } from "../Utils/InstructionType";
import { ORG, isPromise } from "../Utils/Useful";

export default class TypeDetector {
    private detection = new Map<string, (data: unknown) => boolean>([
        [
            "p",
            (data: unknown): boolean => {
                return (
                    typeof data !== "object" &&
                        typeof data !== "function" ||
                    typeof data === TS.udf ||
                    data == null
                );
            }
        ],
        [
            "a",
            (data: unknown): boolean => {
                return Array.isArray(data);
            }
        ],
        [
            "ab",
            (data: unknown): boolean => {
                return (
                    data instanceof ArrayBuffer ||
                    (typeof SharedArrayBuffer !== TS.udf &&
                        data instanceof SharedArrayBuffer)
                );
            }
        ],
        [
            "ta",
            (data: unknown): boolean => {
                const buffer = (data as any)?.buffer;
                return (
                    buffer instanceof ArrayBuffer ||
                    (typeof SharedArrayBuffer !== TS.udf &&
                        buffer instanceof SharedArrayBuffer)
                );
            }
        ],
        [
            "pms",
            (data: unknown | Promise<unknown>): boolean => {
                const valid = isPromise(data);
                if (valid) {
                    console.warn("Potentially invalid type");
                    console.trace(data);
                }
                return valid;
            }
        ],
        [
            "sym",
            (data: unknown): boolean => {
                return (
                    typeof data === "symbol" ||
                    (typeof data === "object" &&
                        Object.prototype.toString.call(data) === "[object Symbol]")
                );
            }
        ],
        [
            "ref",
            (data: unknown): boolean => {
                return typeof data === "object" || typeof data === "function";
            }
        ]
    ]);

    // Returns a tuple:
    //   [isOrganic: boolean, detectedType: string]
    public detectType(
        data: unknown,
        transfer: unknown[] = []
    ): [boolean, string] {
        const organic = extract(data) as any;
        if (organic?.[ORG.type]) {
            return [true, organic[ORG.type] as string];
        }

        if (transfer.indexOf(data) >= 0) {
            return [false, "tf"];
        }

        for (const [type, validator] of this.detection) {
            if (validator(data)) {
                return [false, type];
            }
        }
        return [false, "unk"];
    }
}