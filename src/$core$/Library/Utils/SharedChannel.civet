import { TS, PMS } from "./Alias";
import { type MPromise, isPromise } from "./Useful";

const AT: Atomics | any = typeof Atomics !== TS.udf ? Atomics : {};

export default class SharedChannel<T = unknown> {
    #sharedBuffer: SharedArrayBuffer | null;
    #byteOffset: number;
    $binCoder: any;

    constructor(sharedBuffer: SharedArrayBuffer | null, byteOffset = 0, binCoder: any = null) {
        this.#sharedBuffer = sharedBuffer;
        this.#byteOffset = byteOffset;
        this.$binCoder = binCoder;
    }

    [TS.rv](object: T | Uint8Array | unknown = {}) {
        const data = this.$binCoder?.encode?.(object ?? {}) ?? new Uint8Array([]);
        return this.$resolveWith(data);
    }

    [TS.rj](e: Error | unknown): never {
        throw e;
    }

    waitAuto(timeout = 1000): unknown {
        return typeof document !== "undefined" ? this.waitAsync(timeout) : this.waitSync(timeout);
    }

    waitSync(timeout = 1000): unknown {
        const result = this.$waitSync(timeout);
        return result ? this.$binCoder.decode(result) : null;
    }

    waitAsync(timeout = 1000): unknown {
        return null;
    }

    $resolveWith(binaryData: Uint8Array | Uint8ClampedArray | Int8Array): void {
        if (!this.#sharedBuffer) return;

        // Grow buffer if necessary.
        if (this.#sharedBuffer.byteLength - this.#byteOffset < binaryData.byteLength + 8) {
            this.#sharedBuffer?.grow?.(this.#byteOffset + binaryData.byteLength + 8);
        }

        const int32 = new Int32Array(this.#sharedBuffer, this.#byteOffset, 2);
        if (AT.load(int32, 0) !== 0) {
            new Uint8Array(this.#sharedBuffer, this.#byteOffset + 8, binaryData.byteLength).set(binaryData);

            // Write length and trigger notification.
            AT.store(int32, 1, binaryData.byteLength);
            AT.store(int32, 0, 1);
            AT.notify(int32, 0);
            AT.store(int32, 0, 0);
        }
    }

    $initials(): void {
        if (!this.#sharedBuffer) return;
        const int32 = new Int32Array(this.#sharedBuffer, this.#byteOffset, 2);
        AT.store(int32, 1, 0);
        AT.store(int32, 0, 1);
    }

    $promised(timeout = 1000): Promise<Uint8Array> | any {
        if (!this.#sharedBuffer) return;
        const int32 = new Int32Array(this.#sharedBuffer, this.#byteOffset, 2);
        const promise = AT.waitAsync(int32, 0, 1, timeout)?.value;

        if (promise?.async) {
            return promise
                .then(() => {
                    if (this.#sharedBuffer) {
                        return new Uint8Array(this.#sharedBuffer, this.#byteOffset + 8, int32[1]);
                    }
                    return null;
                })
                .catch(console.trace);
        }

        return new PMS((_, reject: (reason: any) => void) => reject(promise));
    }

    $waitSync(timeout = 1000): Uint8Array | null {
        if (!this.#sharedBuffer) return null;
        const int32 = new Int32Array(this.#sharedBuffer, this.#byteOffset, 2);
        const result = AT.wait(int32, 0, 1, timeout);
        return result === "ok"
            ? new Uint8Array(this.#sharedBuffer, this.#byteOffset + 8, int32[1])
            : null;
    }
}

export const doOnlyAfterResolve = <T>(
    meta: MPromise<T>,
    cb: (value: T) => MPromise<T> | null | void
): MPromise<any> | null | void => {
    if (isPromise(meta)) {
        const chain = (meta as Promise<T>).then(cb).catch(console.trace) ?? cb(meta);
        return chain;
    }

    if (typeof SharedChannel !== TS.udf && meta instanceof SharedChannel) {
        return doOnlyAfterResolve((meta as SharedChannel<T>).waitAuto() as T, cb);
    }

    return cb(meta as T);
};

SharedChannel.prototype.waitAsync = function (timeout = 1000): unknown {
    const result = this.$promised(timeout);
    return doOnlyAfterResolve(result, (bin: unknown | Uint8Array) => {
        return bin ? this.$binCoder?.decode?.(bin as Uint8Array) : null;
    });
};