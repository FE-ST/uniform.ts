import { ORG, type IMeta } from "./OrganicType";
import { doOnlyAfterResolve, type IWrap, type MPromise } from "./Useful";

// Define an interface for the function proxy with attached data and stringify methods.
interface OrganicFunction extends Function {
    [ORG.data]?: unknown;
    stringify: () => string;
    prototype: {
        stringify: () => string;
    };
}

// MakeReference accepts any data and returns a proxy function or the data itself.
export const MakeReference = (data: unknown = null): Function | object => {
    // If data is null or a primitive and not a function or object, return it directly.
    if (
        data == null ||
        (typeof data !== "function" && typeof data !== "object")
    ) {
        return data;
    }

    // If data is already a function and has an attached ORG.data, return it as is.
    if (typeof data === "function" && (data as any)[ORG.data] !== undefined) {
        return data;
    }

    // Create a proxy function.
    const fx = function (this: any): void {
        if (this) {
            this[ORG.data] = data;
        }
    } as OrganicFunction;

    // Add stringify methods to the function and its prototype.
    fx.prototype.stringify = function (): string {
        return JSON.stringify(this[ORG.data] ?? "{}");
    };

    fx.stringify = (): string => {
        return JSON.stringify(data ?? "{}");
    };

    // Assign original data to the property keyed by ORG.data.
    fx[ORG.data] = data;

    return fx;
};

// bindCtx attempts to bind the provided context to the given function if applicable.
export const bindCtx = (gt: unknown, ref: unknown = null): unknown => {
    if (typeof gt == "function" && typeof gt?.bind == "function" && (typeof ref == "object" || typeof ref == "function")) {
        // may be organic or context detached
        return gt?.bind?.(ref) ?? gt;
    }
    return gt;
};

// Create a WeakMap for wrapping objects.
export const wrapWeakMap: WeakMap<object, unknown> = new WeakMap();
export const prepare = <T extends unknown>(w: IWrap<T>|T|IMeta): any => {
    return doOnlyAfterResolve(w, (wrap: any)=>{
        if (wrap?.[ORG.data]) return wrap?.[ORG.data];
        const organic = wrapWeakMap.get(wrap) ?? wrap;
        return organic?.[ORG.data] ?? organic;
    });
}

export const redirect = <T extends unknown>(w: IWrap<T>|MPromise<T>|MPromise<IMeta>): MPromise<IMeta> => {
    return doOnlyAfterResolve(w, (wrap: any) => {
        const pt = prepare(wrap);
        return ((pt?.[ORG.uuid] || pt?.[ORG.type]) as string|null) ? pt : null;
    });
}

export const extract = <T extends unknown>(w: IWrap<T>|MPromise<T>|MPromise<IMeta>): MPromise<IMeta> => {
    return doOnlyAfterResolve(w, (wrap: any) => {
        const pt = prepare(wrap);
        return ((pt?.[ORG.uuid] || pt?.[ORG.type] as string|null)) ? pt : null;
    });
}
