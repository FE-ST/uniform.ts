import { PMS, TS } from "./Alias";
import SharedChannel from "./SharedChannel";
import { UUIDv4 } from "./Useful";

export const HANG_TIMEOUT = 2000;

export default class PromiseStack<T> {
    // map: key â†’ either a promise with resolvers or a shared channel
    #map: Map<string, PromiseWithResolvers<T> | SharedChannel<T>> = new Map();

    get sync() {
        return this.syncExcept();
    }

    private syncExcept(excludeKey: string = "") {
        const items = Array.from(this.#map.entries())
            .filter(([key]) => key !== excludeKey)
            .map(([, item]) => item);
        return PMS.allSettled(items);
    }

    get(key: string) {
        return this.#map.get(key);
    }

    [TS.rjb](name: string, reason: unknown) {
        const item = this.#map.get(name);
        this.#map.delete(name);
        // @ts-ignore: TS.rj is expected to be present on the stored type
        item?.[TS.rj]?.(reason ?? null);
        return this;
    }

    [TS.rvb](name: string, value: unknown) {
        const item = this.#map.get(name);
        this.#map.delete(name);
        // @ts-ignore: TS.rv is expected to be present on the stored type
        item?.[TS.rv]?.(value ?? null);
        return this;
    }

    hook(
        key: string | null = null,
        buffer: SharedArrayBuffer | null = null
    ): [string, SharedChannel<T>, SharedArrayBuffer | ArrayBuffer | unknown] {
        const channel = new SharedChannel<T>(buffer);
        key = key || UUIDv4();
        this.#map.set(key, channel);

        setTimeout(() => {
            if (this.#map.has(key)) {
                this[TS.rjb](key, "hang-timeout");
            }
        }, HANG_TIMEOUT);

        return [key, channel, buffer];
    }

    [TS.cs]<U = T>(
        key: string | null = null
    ): [string, SharedChannel<U>, SharedArrayBuffer | ArrayBuffer | unknown] {
        const buffer = new SharedArrayBuffer(16);
        const channel = new SharedChannel<U>(buffer);
        key = key || UUIDv4();
        this.#map.set(key, channel);

        setTimeout(() => {
            if (this.#map.has(key)) {
                this[TS.rjb](key, "hang-timeout");
            }
        }, HANG_TIMEOUT);

        return [key, channel, buffer];
    }

    [TS.cr](key: string | null = null): [string, Promise<T>] {
        const pm = PMS.withResolvers<T>();
        key = key || UUIDv4();
        this.#map.set(key, pm);

        setTimeout(() => {
            if (this.#map.has(key)) {
                this[TS.rjb](key, "hang-timeout");
            }
        }, HANG_TIMEOUT);

        return [key, pm.promise];
    }
}