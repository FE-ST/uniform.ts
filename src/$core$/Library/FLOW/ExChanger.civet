import ObjectProxy from "../../Interface/ObjectProxy";
import { doOnlyAfterResolve, isPromise, UUIDv4, type IWrap } from "../Utils/Useful";
import { extract, MakeReference } from "../Utils/InstructionType";
import RemoteReferenceHandler from "../Handlers/RemoteHandler";
import MemoryHandler from "../Handlers/MemoryHandler";
import DataHandler from "../Handlers/DataHandler";
import PromiseHandler from "../Handlers/PromiseHandler";
import type UniversalHandler from "../Handlers/UniversalHandler";
import type PreCoding from "../PreCoding/PreCoding";
import type UUIDMap from "../Utils/UUIDMap";
import FLOW from "./FLOW";
import * as $M from "./MessageChannel";
import { ORG, IMeta, bindWithContext } from "../Utils/OrganicType";
import { TS } from "../Utils/Alias";

export default class ExChanger {
    #flow: FLOW | null = null;
    #handler: UniversalHandler | null = null;
    #memoryPool: UUIDMap | null = null;
    #coder: PreCoding | null = null;

    constructor(context: unknown) {
        if (typeof context !== TS.udf && context) {
            bindWithContext(context, this);
            this.#flow = new FLOW(context);
        } else {
            console.warn("Context not bounded!");
        }
    }

    initialize() {
        if (this.#flow?.importToSelf($M)) {
            this.#coder = this.#flow.$imports?.$cd || this.#coder;
            this.#memoryPool = this.#flow.$imports?.$mp || this.#memoryPool;
        } else {
            throw new Error("Worker Engine Not Defined!");
        }

        this.#handler = this.#flow.$imports?.$dh || this.#handler;
        if (this.#handler) {
            this.#handler.$addHandler("loc", new MemoryHandler(this.#memoryPool));
            this.#handler.$addHandler("rmt", new RemoteReferenceHandler(this));
            this.#handler.$addHandler("pms", new PromiseHandler());
            this.#handler.$addHandler("dir", new DataHandler());
        } else {
            throw new Error("Invalid Native Module!");
        }

        return this;
    }

    get $imports() {
        return this.#flow?.$imports || {};
    }

    get $sync() {
        return this.#flow?.sync();
    }

    async sync() {
        await this.$sync;
        return this;
    }

    $makePromise<T>(target: T | Promise<T>): IWrap<T> | null {
        try {
            const ext = (target as any)?.[ORG.data] ?? target;
            if (isPromise(target)) {
                return new Proxy(MakeReference(ext), new ObjectProxy(this.#handler?.$getHandler("pms"))) as IWrap<T>;
            }
            return target as IWrap<T>;
        } catch (e) {
            console.error(e);
            return null;
        }
    }

    $act<T>(result: T | Promise<T>, cb: (result: T) => void): IWrap<T> | null {
        try {
            return this.$makePromise(doOnlyAfterResolve(result, cb));
        } catch (e) {
            console.error(e);
            return null;
        }
    }

    $request<T>(cmd: string, meta: unknown, args: unknown[]): IWrap<T> | null {
        const transfer: unknown[] = [];
        const encoded = this.#coder?.encode([cmd, meta, ...args], transfer) as any[];
        const result = this.#flow?.callTask(encoded, transfer);
        try {
            return this.$act(result, (res) => this.#coder?.decode?.(res, transfer)) as IWrap<T> | null;
        } catch (e) {
            console.error(e);
            return null;
        }
    }

    $importToUnit(source: string) {
        return this.#flow?.importToUnit(source);
    }

    $importToSelf(module: unknown) {
        return this.#flow?.importToSelf(module);
    }

    register<T extends object | Function>(object: T, name = ""): string | null {
        return this.#memoryPool?.add(object, name) || "";
    }

    access<T>(name = ""): IWrap<T> | null {
        if (this.#memoryPool?.has(name)) {
            return this.#memoryPool.get(name) as IWrap<T> | null;
        }
        return this.$request("access", { [ORG.type]: "ref", [ORG.uuid]: name }, []) as IWrap<T> | null;
    }

    transfer<T>($node: T | null = null, name: string = "") {
        return this.$act($node, (node) => {
            const meta: IMeta = extract(node) as IMeta;
            const uuid: string = name || (meta as any)?.[ORG.uuid] || UUIDv4();
            const real: T = (meta as any)?.[ORG.node] ?? this.#memoryPool?.get(uuid) ?? node;

            if (this.#handler) {
                return new Proxy(
                    MakeReference({
                        [ORG.type]: "tf",
                        [ORG.uuid]: uuid,
                        [ORG.node]: real
                    }),
                    new ObjectProxy(this.#handler)
                );
            }
            return null;
        });
    }

    doTransfer<T>($name: string | IMeta | IWrap<IMeta> = "", node: T | null = null): IWrap<T> | null {
        return this.$act<any>($name, (name: any): IWrap<T> | null => {
            return this.$act(node, (result: any): IWrap<T> | null => {
                const esm: IMeta = extract(name) as IMeta;
                const meta: IMeta = extract(result) as IMeta;
                const uuid: string = (esm?.[ORG.uuid] || name || meta?.[ORG.uuid] || UUIDv4() || "") as string;
                const real: T = meta?.[ORG.node] ?? this.#memoryPool?.get(uuid) ?? result ?? esm?.[ORG.node];

                if (esm) esm[ORG.uuid] = uuid || "";
                if (meta) meta[ORG.uuid] = uuid || "";

                if (!result && real) {
                    return real as IWrap<T>;
                }

                result = real
                    ? this.$request(
                            "access",
                            { [ORG.type]: "tf", [ORG.uuid]: uuid, [ORG.node]: real },
                            []
                        )
                    : this.$request(
                            "transfer",
                            esm ?? { [ORG.type]: "ref", [ORG.uuid]: uuid },
                            []
                        );
                return result as IWrap<T>;
            });
        });
    }
}