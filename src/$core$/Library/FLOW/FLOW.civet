// deno-lint-ignore-file no-explicit-any
import { Transferable, doOnlyAfterResolve } from "../Utils/Useful";
import PromiseStack from "../Utils/PromiseStack";
import { TS } from "../Utils/Alias";

const PM = "postMessage";

export default class FLOW {
    #worker: any | null = null;
    #promiseStack: PromiseStack<unknown> = new PromiseStack();
    #imports: Record<string, any> = {};

    constructor(worker: any | null = null) {
        this.#worker = worker;
        (worker ??= this.#worker)?.addEventListener("message", (ev: any) => {
            if (!ev?.data) {
                console.log(ev);
                return;
            }
            const { cmd, uuid, dir, status, shared } = ev.data;
            if (dir === "req") {
                this.#handleRequest(ev.data);
            } else if (dir === "res") {
                this.#handleResponse(ev.data);
            }
        });
    }

    get $imports() {
        return this.#imports;
    }

    importToSelf(module: any) {
        Object.assign(this.#imports, module?.default ?? module);
        return this;
    }

    importToUnit(source: string, sync = false) {
        const [uuid, promise, shared] = this.#promiseStack[sync ? TS.cs : TS.cr]();
        this.#worker?.[PM]?.({
            status: "pending",
            handler: "$import",
            cmd: "import",
            dir: "req",
            uuid,
            source,
            shared,
        });
        return promise;
    }

    sync(sync = false) {
        const [uuid, promise, shared] = this.#promiseStack[sync ? TS.cs : TS.cr]();
        this.#worker?.[PM]?.({
            status: "pending",
            handler: null,
            cmd: "ping",
            dir: "req",
            uuid,
            shared,
        });
        return promise;
    }

    callTask(args: any[] = [], transfer: unknown[] = [], sync = false) {
        const [uuid, promise, shared] = this.#promiseStack[sync ? TS.cs : TS.cr]();
        doOnlyAfterResolve(args, (resolvedArgs) => {
            this.#worker?.[PM]?.({
                status: "pending",
                handler: "$handler",
                cmd: "call",
                dir: "req",
                uuid,
                args: resolvedArgs,
                shared,
            }, [...new Set(transfer || [])].filter(
                (item) => Transferable.some((T) => item instanceof T)
            ) as StructuredSerializeOptions);
        });
        return promise;
    }

    #handleRequest(data: any) {
        const { cmd, uuid, shared } = data;
        switch (cmd) {
            case "ping": {
                this.#worker?.[PM]?.({
                    cmd,
                    uuid,
                    dir: "res",
                    status: "ok",
                    result: "ok",
                    shared: null,
                });
                break;
            }
            case "import": {
                import(/* @vite-ignore */ ("" + data.source))
                    .then((mod) => {
                        Object.assign(this.#imports, mod.default ?? mod);
                        this.#worker?.[PM]?.({
                            cmd,
                            uuid,
                            dir: "res",
                            status: "ok",
                            result: "ok",
                            shared: null,
                        });
                    })
                    .catch((e) => {
                        console.error(e);
                        console.trace(e);
                        this.#worker?.[PM]?.({
                            cmd,
                            uuid,
                            dir: "res",
                            status: "error",
                            result: "unsupported",
                            shared: null,
                        });
                    });
                break;
            }
            case "call": {
                if (shared) this.#promiseStack.hook(uuid, shared);
                try {
                    const task = this.#imports[data.handler]?.apply(self, [data]) ?? data.args;
                    doOnlyAfterResolve(task, (syncOrAsync: any) => {
                        doOnlyAfterResolve(syncOrAsync, (pass: any) => {
                            const [$r, transfer] = pass;
                            doOnlyAfterResolve($r, (result: any) => {
                                this.#worker?.[PM]?.({
                                    handler: "$resolver",
                                    status: "ok",
                                    cmd,
                                    uuid,
                                    dir: "res",
                                    result,
                                    shared,
                                }, [...new Set(Array.from(transfer || []))]
                                    .filter((item) => Transferable.some((T) => item instanceof T)) as StructuredSerializeOptions);
                                this.#promiseStack[TS.rvb](uuid, result);
                            });
                        });
                    });
                } catch (e: any) {
                    console.error(e);
                    console.trace(e);
                    const reason = e.message;
                    this.#worker?.[PM]?.({
                        handler: "$resolver",
                        status: "error",
                        cmd,
                        uuid,
                        dir: "res",
                        result: reason,
                        shared: null,
                    }, []);
                    this.#promiseStack[TS.rjb](uuid, reason);
                }
                break;
            }
            default: {
                console.error(`Internal command: ${cmd} not supported.`);
                this.#worker?.[PM]?.({
                    cmd,
                    uuid,
                    dir: "res",
                    status: "error",
                    result: "unk",
                });
            }
        }
    }

    #handleResponse(data: any) {
        const { uuid, status } = data;
        try {
            const resolved = this.#imports[data.handler]?.apply(self, [data]) ?? data.result ?? null;
            this.#promiseStack[status !== "error" ? TS.rvb : TS.rjb](uuid, resolved);
        } catch (e: any) {
            console.error(e);
            console.trace(e);
            this.#promiseStack[TS.rjb](uuid, e?.message);
        }
    }
}